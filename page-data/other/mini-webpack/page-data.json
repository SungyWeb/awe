{"componentChunkName":"component---src-templates-blog-jsx","path":"/other/mini-webpack/","result":{"data":{"markdownRemark":{"html":"<h1>从零实现一个迷你Webpack</h1>\n<p>Webpack是当前使用较多的一个打包工具，下面以打包为目的，实现一个简易版的webpack，支持单入口文件的打包，不涉及插件、分包等。</p>\n<h1>前置知识</h1>\n<p>以webpack 5.x为例，先来简单看个demo，可以看到webpac的输入、输出的代码是什么样的。</p>\n<p>源码</p>\n<pre><code class=\"language-js\">// index.js\r\nrequire(\"./a.js\");\r\nconsole.log(\"入口文件\");\r\n\r\n// a.js\r\nrequire(\"./b.js\");\r\nconsole.log(\"a.js 文件\");\r\n\r\n// b.js\r\nconsole.log(\"b.js 文件\");\n</code></pre>\n<p>打包后</p>\n<pre><code class=\"language-js\">(() => {\r\n  var __webpack_modules__ = {\r\n    \"./a.js\": (\r\n      __unused_webpack_module,\r\n      __unused_webpack_exports,\r\n      __webpack_require__\r\n    ) => {\r\n      __webpack_require__(/*! ./b.js */ \"./b.js\");\r\n\r\n      console.log(\"a.js 文件\");\r\n    },\r\n\r\n    \"./b.js\": () => {\r\n      console.log(\"b.js 文件\");\r\n    },\r\n  };\r\n\r\n  // The module cache\r\n  var __webpack_module_cache__ = {};\r\n\r\n  // The require function\r\n  function __webpack_require__(moduleId) {\r\n    // Check if module is in cache\r\n    var cachedModule = __webpack_module_cache__[moduleId];\r\n    if (cachedModule !== undefined) {\r\n      return cachedModule.exports;\r\n    }\r\n    // Create a new module (and put it into the cache)\r\n    var module = (__webpack_module_cache__[moduleId] = {\r\n      // no module.id needed\r\n      // no module.loaded needed\r\n      exports: {},\r\n    });\r\n\r\n    // Execute the module function\r\n    __webpack_modules__[moduleId](module, module.exports, __webpack_require__);\r\n\r\n    // Return the exports of the module\r\n    return module.exports;\r\n  }\r\n  var __webpack_exports__ = {};\r\n\r\n  (() => {\r\n    __webpack_require__(/*! ./a.js */ \"./a.js\");\r\n\r\n    console.log(\"入口文件\");\r\n  })();\r\n})();\r\n\n</code></pre>\n<p>可以看到打包产物是一个立即执行函数，将除了入口文件的代码以文件名为key，以文件内代码为value，保存到名为<code>__webpack_modules__</code>的对象中；接着实现了一个<code>__webpack_require__</code>方法，并将代码中的<code>require</code>替换成该函数；最后执行入口文件代码。</p>\n<p>通过入口文件，将直接依赖或间接依赖以module的形式组织到一起，并通过自行实现的<code>require</code>实现模块的同步加载。</p>\n<h1>初始化参数</h1>\n<p>webpack函数接收一些配置项，并返回一个<a href=\"https://www.webpackjs.com/api/node/#compiler-instance\">compiler对象</a>，compiler对象包含<code>run</code>方法来执行编译，即大致流程如下</p>\n<pre><code class=\"language-js\">const webpack = require('webpack')\r\nconst compiler = webpack(options)\r\ncompiler.run((err) => {   })\n</code></pre>\n<p>先来实现webpack方法</p>\n<pre><code class=\"language-js\">function webpack(options) {\r\n  const compiler = new Compiler(options)\r\n  return compiler\r\n}\r\n\r\nmodule.exports = webpack\n</code></pre>\n<p>接下来实现<code>Compiler</code>类，首先要明确编译过程需要做的事情</p>\n<ol>\n<li>读取入口文件，将入口文件交给匹配的loader处理，返回处理后的代码</li>\n<li>开始编译loader处理完的代码</li>\n<li>如果代码中依赖了其他文件，则对require函数替换为<code>__webpack_require__</code>，保存该文件的处理结果，同时让其他文件回到第1步进行处理，不断循环</li>\n<li>编译结束后，每个文件都有对应的处理结果，将这些文件的文件结果从最初的的入口文件开始，组织到一起</li>\n</ol>\n<p>语法树AST相关的生成、遍历、转换等操作需要借助<code>babel</code></p>\n<pre><code class=\"language-mermaid\">graph TD\r\n\tA --> B\n</code></pre>\n<pre><code class=\"language-js\">const fs = require(\"fs\");\r\nconst path = require(\"path\");\r\nconst parser = require(\"@babel/parser\");\r\nconst traverser = require(\"@babel/traverse\");\r\nconst t = require(\"@babel/types\");\r\nconst generate = require(\"babel-generator\");\r\n\r\nclass Compiler {\r\n  constructor(options) {\r\n    this.options = options || {};\r\n\r\n    // 保存编译过的module\r\n    this.modules = new Set();\r\n  }\r\n\r\n  run(callback) {\r\n    const entryModule = this.build(\r\n      path.join(process.cwd(), this.options.entry)\r\n    );\r\n    const entryChunk = this.buildChunk(\"entry\", entryModule);\r\n    this.generateFile(entryChunk, callback);\r\n  }\r\n\r\n  build(modulePath) {\r\n    let originCode = fs.readFileSync(modulePath);\r\n    originCode = this.dealWidthLoader(modulePath, originCode.toString());\r\n    return this.dealDependencies(originCode, modulePath);\r\n  }\r\n\r\n  // 将文件源码交给对应的loader\r\n  dealWidthLoader(modulePath, originCode) {\r\n    if (this.options.module &#x26;&#x26; this.options.module.rules) {\r\n      [...this.options.module.rules].reverse().forEach((rule) => {\r\n        if (rule.test.test(modulePath)) {\r\n          const loaders = [...rule.use].reverse();\r\n          loaders.forEach((loader) => (originCode = loader(originCode)));\r\n        }\r\n      });\r\n    }\r\n\r\n    return originCode;\r\n  }\r\n\r\n  // 根据ast 处理依赖\r\n  dealDependencies(code, modulePath) {\r\n    const fullPath = path.relative(process.cwd(), modulePath);\r\n    // 创建模块对象\r\n    const module = {\r\n      id: fullPath,\r\n      dependencies: [],\r\n    };\r\n\r\n    // 这里使用@babel/parser提供的语法树解析方法\r\n    // https://babel.docschina.org/docs/en/babel-parser/\r\n    const ast = parser.parse(code, {\r\n      sourceType: \"module\",\r\n    });\r\n\r\n    // 深度遍历优先 遍历语法树\r\n    traverser.default(ast, {\r\n      // 对语法树中特定的节点进行操作 参考@babel/types （特定节点类型）\r\n      // CallExpression 特定节点\r\n      CallExpression: (nodePath) => {\r\n        const node = nodePath.node;\r\n        if (node.callee.name === \"require\") {\r\n          const requirePath = node.arguments[0].value;\r\n\r\n          const moduleDirName = path.dirname(modulePath);\r\n          const fullPath = path.relative(\r\n            __dirname,\r\n            path.join(moduleDirName, requirePath)\r\n          );\r\n\r\n          // t.identifier创建__webpack_require__标识符\r\n          // 赋值给node.calllee\r\n          // 替换掉了原来的 require\r\n          node.callee = t.identifier(\"__webpack_require__\");\r\n\r\n          // 将依赖的路径修改为以当前路径行为基准\r\n          // t.stringLitera 创建了string类型\r\n          node.arguments = [t.stringLiteral(fullPath)];\r\n\r\n          // 查看这个module是否已经被处理过\r\n          const exitModule = [...this.modules].find(\r\n            (item) => item.id === fullPath\r\n          );\r\n          if (!exitModule) {\r\n            module.dependencies.push(fullPath);\r\n          }\r\n        }\r\n      },\r\n    });\r\n\r\n    // 根据新的ast生成代码\r\n    const _code = generate.default(ast);\r\n    // 保存最新的代码\r\n    module._source = _code.code;\r\n\r\n    // 遍历所有依赖 并保存到modules\r\n    module.dependencies.forEach((dep) => {\r\n      const depModule = this.build(dep);\r\n      this.modules.add(depModule);\r\n    });\r\n    // 返回当前module\r\n    return module;\r\n  }\r\n\r\n  buildChunk(entryName, entryModule) {\r\n    return {\r\n      name: entryName,\r\n      entryModule,\r\n      modules: this.modules,\r\n    };\r\n  }\r\n\r\n  getCode(entryChunk) {\r\n    return `\r\n(() => {\r\n  var __webpack_modules__ = {\r\n    ${Array.from(entryChunk.modules)\r\n      .map(\r\n        (module) => `\r\n      \"${module.id}\": (module, __unused_webpack_exports, __webpack__require__) => {\r\n        ${module._source}\r\n      }\r\n    `\r\n      )\r\n      .join(\",\")}\r\n  }\r\n\r\n  var __webpack_module_cache__ = {};\r\n\r\n  function __webpack_require__(moduleId) {\r\n    var cachedModule = __webpack_module_cache__[moduleId];\r\n    if(cachedModule !== undefined) {\r\n      return cachedModule.exports\r\n    }\r\n\r\n    var module = (__webpack_module_cache__[moduleId] = {\r\n      exports: {}\r\n    })\r\n\r\n    __webpack_modules__[moduleId](\r\n      module,\r\n      module.exports,\r\n      __webpack_require__\r\n    );\r\n\r\n    return module.exports;\r\n  }\r\n\r\n  var __webpack_exports__ = {};\r\n\r\n  (() => {\r\n    ${entryChunk.entryModule._source}\r\n  })();\r\n})();\r\n    `;\r\n  }\r\n  generateFile(entryChunk, callback) {\r\n    const code = this.getCode(entryChunk);\r\n\r\n    if (!fs.existsSync(this.options.output.path)) {\r\n      fs.mkdirSync(this.options.output.path);\r\n    }\r\n    fs.writeFile(\r\n      path.join(\r\n        this.options.output.path,\r\n        this.options.output.filename.replace(\"[name]\", entryChunk.name)\r\n      ),\r\n      code,\r\n      (err) => callback &#x26;&#x26; callback(err)\r\n    );\r\n  }\r\n}\r\n\r\nfunction webpack(options) {\r\n  const compiler = new Compiler(options);\r\n  return compiler;\r\n}\r\n\r\nmodule.exports = webpack;\r\n\n</code></pre>","frontmatter":{"title":"实现一个简易webpack"}}},"pageContext":{"slug":"/other/mini-webpack/"}},"staticQueryHashes":["3649515864","63159454"],"slicesMap":{}}