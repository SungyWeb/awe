{"componentChunkName":"component---src-pages-index-js","path":"/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"0930b47e-6267-5545-930d-82ff4c6a1e46","fields":{"slug":"/css/animate/"},"html":"<h1>背景</h1>\n<p>前端动画场景需求很多，有些朋友技术实现方案也不知道怎么选，下面从各个角度对动画整体体系进行分类，让我们清晰的了解动画整个体系。</p>\n<h1>分类</h1>\n<h2>业务角度</h2>\n<p>从业务角度来说，动画可分为展示型和交互型。</p>\n<ul>\n<li>\n<p>展示型动画 类似 Gif 图片或者一段视频，来增加用户的视觉体验，主要特点体现在用户可以感知，但无法参与。实现方式有 Gif、canvas、CSS3 动画等。</p>\n</li>\n<li>\n<p>交互型动画 在动画播放的过程中用户可以进行操作，如点击、滑动等。但是通过原生代码实现交互动画是很复杂的，同时性能和兼容性也不容忽视，比较好的方案还是寻求相关框架。</p>\n</li>\n</ul>\n<h2>绘制技术角度</h2>\n<p>不管采用什么方式来制作动画，最终呈现到前端的页面无非是三种形式： <code>div</code> <code>cavas</code> <code>svg</code>。为了简单也可以使用视频，除非动画的播放场景固定，不然很容易踩坑。</p>\n<h3>canvas</h3>\n<ul>\n<li>👍 效率高、性能好、可控制高</li>\n<li>👍 能够以<code>png</code>或<code>jpg</code>格式保存图像</li>\n<li>👍 逐像素渲染，适合图像密集的场景，许多对象会被频繁重绘</li>\n<li>👎 不支持事件处理器</li>\n<li>👎 文本渲染能力弱</li>\n</ul>\n<h3>div</h3>\n<ul>\n<li>👍 Dom 动画，可以通过 css 或 js 实现</li>\n<li>👍 适合简单的、数量少的、复杂度低的动画场景</li>\n</ul>\n<h3>svg</h3>\n<ul>\n<li>👍 基于<code>xml</code>的 2D 图形，矢量图，不会失真，不依赖分辨率</li>\n<li>👍 支持时间处理器，精确控制任意元素，且 svg 对象属性变化时，浏览器能够自动重绘</li>\n<li>👍 适合大型渲染区域的应用程序（如地图）</li>\n<li>👎 复杂度高会影响渲染速度（任何过度使用 dom 的应用都不快）</li>\n<li>👎 不适合游戏应用</li>\n</ul>\n<p>总体来说，canvas 和 svg 都是 2D 作图，svg 是矢量图，适合复杂度不高的应用场景；canvas 是位图，逐像素渲染，适合游戏。</p>\n<h2>动画类型</h2>\n<h3>序列帧动画</h3>\n<p>将静态的图片进行快速的播放，形成一个动态的动画效果。</p>\n<p>GIF 实现</p>\n<ul>\n<li>画质不佳，颜色支持少，最多 256 色，透明度支持差</li>\n<li>不能直接控制播放、暂停、播放次数等，灵活性差</li>\n<li>会引起页面周期性的绘制，性能比较差</li>\n</ul>\n<p>连续切换图片地址（不推荐）</p>\n<ul>\n<li>多张图片会带来多个 http 请求</li>\n<li>每张图片首次加载时会造成图片切换的闪烁</li>\n<li>不利于文件管理</li>\n</ul>\n<p>连续切换雪碧图位置（推荐）</p>\n<ul>\n<li>可以通过 css、js 控制 dom 或 js 绘制 canvas 实现</li>\n<li>推荐通过<code>transform:translate3d()</code>实现雪碧图位置变化，启动设备<code>GPU</code>来提高性能</li>\n<li>注意<code>animation</code>的<code>animation-timing-function</code>要采用阶梯函数<code>steps()</code>来实现逐帧动画的连续播放</li>\n</ul>\n<h3>关键帧动画</h3>\n<p>在制作动画时，只需要指定几个特殊时刻动画的状态，其余的状态由计算机自动计算补充</p>\n<ul>\n<li>CSS3 Animation 通过除了<code>steps()</code>之外的时间函数实现</li>\n<li>CSS3 Transition 只能设定初始和结束两个关键帧状态，一条<code>transition</code>只能指定一个属性（<code>all</code>除外）</li>\n<li>使用 js 动画库或框架，比如<a href=\"https://animejs.com/documentation/\">Anime.js</a></li>\n</ul>\n<h3>svg 动画</h3>\n<p>SVG 依然是 DOM ，他有自己独有的 Animation 标签，但也支持 CSS 的属性，其实现动画的本质是依赖于线条和填充，线条的变化，导致填充区域的改变，从而引起形状的变化。而线条则依赖于路径和锚点，路径和锚点的改变，直接影响了线条的变化。</p>\n<p>可以用 AI 等 SVG 编辑工具生成 SVG 图片后，配合<a href=\"https://animejs.com/documentation/\">Anime.js</a>、<a href=\"https://greensock.com/\">GSAP</a>等现有库进行动画制作</p>\n<h3>骨骼动画</h3>\n<p>骨骼动画就是把角色的各部分身体部件图片绑定到一根根互相作用连接的“骨头”上，通过控制这些骨骼的位置、旋转方向和放大缩小而生成的动画。</p>\n<p>可以使用类似 <a href=\"http://zh.esotericsoftware.com/\">Spine</a> 和 <a href=\"https://dragonbones.github.io/cn/index.html\">DragonBones</a> 这样的工具，但是做动画真的是一个体力活，你需要不断的调试，以求达到一种让人看起来舒服的状态。</p>\n<h3>3D 动画</h3>\n<p>前端 3D 动画实现可以通过 perspective 属性操作用 CSS 3D 来实现，或者直接借助开源的 Three.js 开源库进行实现。</p>\n<h1>总结</h1>\n<h2>简单的展示型动画：</h2>\n<p>对于比较简单的动画，我们可以先尝试使用原生 CSS 的 transition\\animation 属性来进行实现。</p>\n<h2>简单的展示型动画+弱交互：</h2>\n<p>对于简单的动画展示并且需要有简单的交互行为，比如用户点击一下暂停执行相应操作，待操作完成继续播放动画，交互方面比较偏弱，可以采用 Anime.js 的方案。</p>\n<p>Anime.js 不仅仅支持所有的 CSS 属性，而且可以通过 Timeline，callback， playback controls 来控制动画执行的各个状态，并且 Anime.js 可以配合实现 SVG 动画。</p>\n<h2>复杂的展示型动画：</h2>\n<p>如果所需的资源很小，可以先考虑使用 GIF 动图或者逐帧动画 CSS 实现；</p>\n<p>如果所需的资源较大，可以使用 Lottie 方案，然后设计同学用 AE 到处动画 json，将动画还原为 svg/canvas/html。</p>\n<h2>强交互&#x26;互动小游戏&#x26;骨骼动画：</h2>\n<p>对于交互场景比较负责或者需要做一个小游戏，可以采用 PixiJs，通过 WebGL 来渲染，利用硬件资源，极大的提升性能，在兼容性方面，对于不支持 WebGL 的浏览器，可以使用 canvas 渲染来平稳回退；</p>\n<p>如果是需要展示骨骼动画，可以通过 PixiJs 方案进行渲染由 Spine 或 DragonBones 输出的文件。</p>","frontmatter":{"date":"2022-11-18","title":"前端动效","anthor":"sungy"},"excerpt":"<h1>背景</h1>\n<p>前端动画场景需求很多，有些朋友技术实现方案也不知道怎么选，下面从各个角度对动画整体体系进行分类，让我们清晰的了解动画整个体系。</p>\n<h1>分类</h1>\n<h2>业务角度</h2>\n<p>从业务角度来说，动画可分为展示型和交互型。</p>\n<ul>\n<li>\n<p>展示型动画 类似 Gif 图片或者一段视频，来增加用户的视觉体验，主要特点体现在用户可以感知，但无法参与。实现方式有 Gif、canvas、CSS3 动画等。</p>\n</li>\n<li>\n<p>交互型动画 在动画播放的过程中用户可以进行操作，如点击、滑动等。但是通过原生代码实现交互动画是很复杂的，同时性能和兼容性也不容忽视，比较好的方案还是寻求相关框架。</p>…</li></ul>"}},{"node":{"id":"3a24fb5a-f852-5263-9387-f31123b13603","fields":{"slug":"/react/hooks/"},"html":"<h1>hooks “必”坑指南</h1>\n<p>React hooks 想必已经不是什么新鲜“玩意”了，它的出现是为了开发者可以在不写<code>class</code>组件的情况使用<code>state</code>及其他 React 特性。</p>\n<h2>动机</h2>\n<p>引入 hooks 的动机，官方也是给出了答案：</p>\n<ul>\n<li>在组件之间复用状态逻辑很难</li>\n<li>复杂组件变得难以理解</li>\n<li>难以理解的 class（this 的指向问题对新手来说并不友好）</li>\n<li>由于业务变动，函数组件不得不改为类组件等等</li>\n</ul>\n<blockquote>\n<p><a href=\"https://zh-hans.reactjs.org/docs/hooks-intro.html#motivation\">React 官方文档-Hook 简介-动机</a></p>\n</blockquote>\n<h2>规矩</h2>\n<h3>命名</h3>\n<p>hooks 不是普通的函数，必须使用<code>use</code>开头命名来表示与普通函数的区别，这样就破坏了函数命名的语义。如 <code>useGetData</code> <code>useTitle</code> 这样的命名，通过名称很难理解它的用意。这就需要一套严格的 hooks 命名规则来规范，如果使用 <code>_</code> 开头或 <code>$</code> 结尾等类似规则可能会更好，当然这并不是什么大问题</p>\n<h3>顺序</h3>\n<p>同一个组件内，hooks 的顺序是不能变化的, 这种要求完全依赖开发者的经验或是 Lint，而站在一般第三方 Lib 的角度看，这种要求调用时序的 API 设计是极为罕见的，非常反直觉。</p>\n<p>最理想的 API 封装应当是给开发者的认知负担最小的。</p>\n<h2>Hooks</h2>\n<h3>useEffect</h3>\n<p><code>React</code>中有两个重要概念 <code>Rendering Code</code> 和 <code>Event Handlers</code></p>\n<p><code>Rendering Code</code>是开发者编写的组件渲染逻辑，最终会返回一段<code>JSX</code>，它应该是不带副作用的纯函数</p>\n<pre><code class=\"language-jsx\">function App() {\n  const [name, updateName] = useState(\"sungy\")\n\n  return &#x3C;div>{name}&#x3C;/div>\n}\n</code></pre>\n<p><code>Event Handlers</code>是事件处理函数，可以包含副作用。如下面的<code>changeName</code>方法就是属于<code>Event Handlers</code></p>\n<pre><code class=\"language-jsx\">function App() {\n  const [name, updateName] = useState(\"sungy\")\n\n  const changeName = () => updateName(\"zhangsan\")\n\n  return &#x3C;div>{name}&#x3C;/div>\n}\n</code></pre>\n<blockquote>\n<p>副作用：数据获取，设置订阅以及手动更改 React 组件中的 DOM 都属于副作用</p>\n</blockquote>\n<p>但是并不是所有的副作用都可以放到<code>Event Handlers</code>中，比如视图渲染后的数据请求、状态改变后的数据请求</p>\n<p>考虑一下默认加载一个列表，点击分页后发起新的请求场景，我们需要组件加载后去发起请求</p>\n<pre><code class=\"language-jsx\">const [pageIndex, setPageIndex] = useState(1)\nuseEffect(() => {\n  fetch(\"xxx\")\n}, [pageIndex])\n</code></pre>\n<p>现在来思考一下，我们的需求是：</p>\n<ul>\n<li><code>pageIndex</code>变化，接下来发起请求</li>\n<li>用户点击页码需要重新获取数据，请求依赖<code>pageIndex</code>为参数</li>\n</ul>\n<p>如果是第二种，那么这是用户行为触发的副作用，相关逻辑应该放到<code>Event Handlers</code>中处理</p>\n<pre><code class=\"language-jsx\">const [pageIndex, setPageIndex] = useState(1)\nuseEffect(() => {\n  fetch(\"xxx\")\n}, [])\n\nconst onPageIndexChange = pageIdx => fetch(\"xxx\")\n</code></pre>\n<p>这样<code>pageIndex</code>的状态与发送请求之间不再有因果关系，后续对<code>pageIndex</code>的修改不会有<strong>无意间触发请求</strong>的顾虑；同样随着业务逻辑复杂，不会导致在<code>useEffect</code>的依赖中添加杂乱的变量，使逻辑无法调试、追踪</p>\n<p>当我们编写组件时，应尽量保证为纯函数。对于组件中的副作用，应明确副作用是视图渲染后主动触发的还是用户行为触发的，前者应该在<code>useEffect</code>中处理， 后者应该放到<code>Event Handlers</code>中处理</p>\n<h3>useRef</h3>\n<p>我们知道 Dom 元素是由 React 创建的，所以 Dom 元素的增删改都是 React 的控制范围。</p>\n<p>当我们用 ref 指向一个节点，执行<code>ref.current</code>的<code>fouce</code>、<code>blur</code>、<code>scrollIntoView</code>、<code>getBoundingClientRect</code> 这些方法时，虽然也是操作了 dom，但是这些在 React 控制范围外；但是当我们执行<code>remove</code>、<code>appendChild</code>等方法时，这就是 React 的控制范围内了，React 期望开发者能够通过 React 来控制，而不是调用原生的 api，这种情况可以称之为<strong>失控</strong></p>\n<pre><code class=\"language-jsx\">function App() {\n  const [show, setShow] = useState(true)\n  const ref = useRef(null)\n\n  return (\n    &#x3C;div>\n      &#x3C;button onClick={() => setShow(false)}>btn1&#x3C;/button>\n      &#x3C;button onClick={() => ref.current.remove()}>btn2&#x3C;/button>\n      {show &#x26;&#x26; &#x3C;p ref={ref}>&#x3C;/p>}\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p><code>btn1</code>通过 React 来移除<code>p</code>元素，<code>btn2</code>通过原生 js 来移除。如果先点<code>btn1</code>再点<code>btn2</code>，那么就会报错。</p>\n<p>这就是 ref 操作 dom 造成失控的情况。</p>\n<p>为了将这种失控控制在单个组件内，React 默认情况下不允许跨组件传递 ref。</p>\n<pre><code class=\"language-jsx\">function Input(props) {\n  return &#x3C;input {...props} />\n}\n\nfunction Form() {\n  const inputRef = useRef()\n  const handleClick = () => {\n    inputRef.current.force()  // btn点击后会报错\n  }\n  return (\n    &#x3C;>\n      &#x3C;button onClick={handleClick}>btn&#x3C;/button>\n      &#x3C;Input ref={inputRef} />\n    &#x3C;/Input>\n  )\n}\n</code></pre>\n<p>为了能够将 ref 传递到子组件，React 提供了<code>forwardRef</code>（forward 这里时传递的意思）方法</p>\n<p>但从 ref 失控的角度看，<code>forwardRef</code>的意图就很明显了：既然开发者手动调用<code>forwardRef</code>破除防止 ref 失控的限制，那他应该知道自己在做什么，也应该自己承担相应的风险。</p>\n<h3>useImperativeHandle</h3>\n<p>续说上文，既然 ref 失控是因为使用了不应该使用的方法（比如 remove），那么可以限制 ref 中只存在可以使用的方法，这样就杜绝了开发者通过 ref 取到 dom 后，执行不该使用的 api，导致 ref 失控的情况。</p>\n<pre><code class=\"language-jsx\">const Input = forwardRef((props, ref) => {\n  const ref = useRef()\n  useImperativeHandle(() => {\n    return {\n      force: () => ref.current.force(),\n    }\n  })\n  return &#x3C;input {...props} ref={ref} />\n})\n</code></pre>\n<p>为了减少 ref 对 DOM 的滥用，可以使用<code>useImperativeHandle</code>限制 ref 传递的数据结构</p>","frontmatter":{"date":"2022-11-15","title":"hooks “必”坑指南","anthor":"sungy"},"excerpt":"<h1>hooks “必”坑指南</h1>\n<p>React hooks 想必已经不是什么新鲜“玩意”了，它的出现是为了开发者可以在不写<code>class</code>组件的情况使用<code>state</code>及其他 React 特性。</p>\n<h2>动机</h2>\n<p>引入 hooks 的动机，官方也是给出了答案：</p>\n<ul>\n<li>在组件之间复用状态逻辑很难</li>\n<li>复杂组件变得难以理解</li>\n<li>难以理解的 class（this 的指向问题对新手来说并不友好）</li>\n<li>由于业务变动，函数组件不得不改为类组件等等</li>…</ul>"}},{"node":{"id":"231bd122-9388-58f2-9070-839b8e553c04","fields":{"slug":"/other/package.json/"},"html":"<h1>package.json 的秘密</h1>\n<p>alsdfjlsdf</p>","frontmatter":{"date":"2022-11-15","title":"package.json 的秘密","anthor":"sungy"},"excerpt":"<h1>package.json 的秘密</h1>\n<p>alsdfjlsdf</p>"}}]}},"pageContext":{}},"staticQueryHashes":["3649515864","63159454"],"slicesMap":{}}