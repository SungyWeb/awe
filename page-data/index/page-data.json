{"componentChunkName":"component---src-pages-index-js","path":"/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"231bd122-9388-58f2-9070-839b8e553c04","fields":{"slug":"/other/package.json/"},"html":"<h1>package.json 的秘密</h1>\n<p>alsdfjlsdf</p>","frontmatter":{"date":"2022-11-15","title":"package.json 的秘密","anthor":"sungy"},"excerpt":"<h1>package.json 的秘密</h1>\n<p>alsdfjlsdf</p>"}},{"node":{"id":"3a24fb5a-f852-5263-9387-f31123b13603","fields":{"slug":"/react/hooks/"},"html":"<h1>hooks “必”坑指南</h1>\n<p>React hooks 想必已经不是什么新鲜“玩意”了，它的出现是为了开发者可以在不写<code>class</code>组件的情况使用<code>state</code>及其他 React 特性。</p>\n<h2>动机</h2>\n<p>引入 hooks 的动机，官方也是给出了答案：</p>\n<ul>\n<li>在组件之间复用状态逻辑很难</li>\n<li>复杂组件变得难以理解</li>\n<li>难以理解的 class（this 的指向问题对新手来说并不友好）</li>\n<li>由于业务变动，函数组件不得不改为类组件等等</li>\n</ul>\n<blockquote>\n<p><a href=\"https://zh-hans.reactjs.org/docs/hooks-intro.html#motivation\">React 官方文档-Hook 简介-动机</a></p>\n</blockquote>\n<h2>规矩</h2>\n<h3>命名</h3>\n<p>hooks 不是普通的函数，必须使用<code>use</code>开头命名来表示与普通函数的区别，这样就破坏了函数命名的语义。如 <code>useGetData</code> <code>useTitle</code> 这样的命名，通过名称很难理解它的用意。这就需要一套严格的 hooks 命名规则来规范，如果使用 <code>_</code> 开头或 <code>$</code> 结尾等类似规则可能会更好，当然这并不是什么大问题</p>\n<h3>顺序</h3>\n<p>同一个组件内，hooks 的顺序是不能变化的, 这种要求完全依赖开发者的经验或是 Lint，而站在一般第三方 Lib 的角度看，这种要求调用时序的 API 设计是极为罕见的，非常反直觉。</p>\n<p>最理想的 API 封装应当是给开发者的认知负担最小的。</p>\n<h2>Hooks</h2>\n<h3>useEffect</h3>\n<p><code>React</code>中有两个重要概念 <code>Rendering Code</code> 和 <code>Event Handlers</code></p>\n<p><code>Rendering Code</code>是开发者编写的组件渲染逻辑，最终会返回一段<code>JSX</code>，它应该是不带副作用的纯函数</p>\n<pre><code class=\"language-jsx\">function App() {\n  const [name, updateName] = useState(\"sungy\")\n\n  return &#x3C;div>{name}&#x3C;/div>\n}\n</code></pre>\n<p><code>Event Handlers</code>是事件处理函数，可以包含副作用。如下面的<code>changeName</code>方法就是属于<code>Event Handlers</code></p>\n<pre><code class=\"language-jsx\">function App() {\n  const [name, updateName] = useState(\"sungy\")\n\n  const changeName = () => updateName(\"zhangsan\")\n\n  return &#x3C;div>{name}&#x3C;/div>\n}\n</code></pre>\n<blockquote>\n<p>副作用：数据获取，设置订阅以及手动更改 React 组件中的 DOM 都属于副作用</p>\n</blockquote>\n<p>但是并不是所有的副作用都可以放到<code>Event Handlers</code>中，比如视图渲染后的数据请求、状态改变后的数据请求</p>\n<p>考虑一下默认加载一个列表，点击分页后发起新的请求场景，我们需要组件加载后去发起请求</p>\n<pre><code class=\"language-jsx\">const [pageIndex, setPageIndex] = useState(1)\nuseEffect(() => {\n  fetch(\"xxx\")\n}, [pageIndex])\n</code></pre>\n<p>现在来思考一下，我们的需求是：</p>\n<ul>\n<li><code>pageIndex</code>变化，接下来发起请求</li>\n<li>用户点击页码需要重新获取数据，请求依赖<code>pageIndex</code>为参数</li>\n</ul>\n<p>如果是第二种，那么这是用户行为触发的副作用，相关逻辑应该放到<code>Event Handlers</code>中处理</p>\n<pre><code class=\"language-jsx\">const [pageIndex, setPageIndex] = useState(1)\nuseEffect(() => {\n  fetch(\"xxx\")\n}, [])\n\nconst onPageIndexChange = pageIdx => fetch(\"xxx\")\n</code></pre>\n<p>这样<code>pageIndex</code>的状态与发送请求之间不再有因果关系，后续对<code>pageIndex</code>的修改不会有<strong>无意间触发请求</strong>的顾虑；同样随着业务逻辑复杂，不会导致在<code>useEffect</code>的依赖中添加杂乱的变量，使逻辑无法调试、追踪</p>\n<p>当我们编写组件时，应尽量保证为纯函数。对于组件中的副作用，应明确副作用是视图渲染后主动触发的还是用户行为触发的，前者应该在<code>useEffect</code>中处理， 后者应该放到<code>Event Handlers</code>中处理</p>\n<blockquote>\n<p><code>useEffect</code></p>\n</blockquote>\n<h3>useRef</h3>\n<p>我们知道 Dom 元素是由 React 创建的，所以 Dom 元素的增删改都是 React 的控制范围。</p>\n<p>当我们用 ref 指向一个节点，执行<code>ref.current</code>的<code>fouce</code>、<code>blur</code>、<code>scrollIntoView</code>、<code>getBoundingClientRect</code> 这些方法时，虽然也是操作了 dom，但是这些在 React 控制范围外；但是当我们执行<code>remove</code>、<code>appendChild</code>等方法时，这就是 React 的控制范围内了，React 期望开发者能够通过 React 来控制，而不是调用原生的 api，这种情况可以称之为<strong>失控</strong></p>\n<pre><code class=\"language-jsx\">function App() {\n  const [show, setShow] = useState(true)\n  const ref = useRef(null)\n\n  return (\n    &#x3C;div>\n      &#x3C;button onClick={() => setShow(false)}>btn1&#x3C;/button>\n      &#x3C;button onClick={() => ref.current.remove()}>btn2&#x3C;/button>\n      {show &#x26;&#x26; &#x3C;p ref={ref}>&#x3C;/p>}\n    &#x3C;/div>\n  )\n}\n</code></pre>\n<p><code>btn1</code>通过 React 来移除<code>p</code>元素，<code>btn2</code>通过原生 js 来移除。如果先点<code>btn1</code>再点<code>btn2</code>，那么就会报错。</p>\n<p>这就是 ref 操作 dom 造成失控的情况。</p>\n<p>为了将这种失控控制在单个组件内，React 默认情况下不允许跨组件传递 ref。</p>\n<pre><code class=\"language-jsx\">function Input(props) {\n  return &#x3C;input {...props} />\n}\n\nfunction Form() {\n  const inputRef = useRef()\n  const handleClick = () => {\n    inputRef.current.force()  // btn点击后会报错\n  }\n  return (\n    &#x3C;>\n      &#x3C;button onClick={handleClick}>btn&#x3C;/button>\n      &#x3C;Input ref={inputRef} />\n    &#x3C;/Input>\n  )\n}\n</code></pre>\n<p>为了能够将 ref 传递到子组件，React 提供了<code>forwardRef</code>（forward 这里时传递的意思）方法</p>\n<p>但从 ref 失控的角度看，<code>forwardRef</code>的意图就很明显了：既然开发者手动调用<code>forwardRef</code>破除防止 ref 失控的限制，那他应该知道自己在做什么，也应该自己承担相应的风险。</p>\n<h3>useImperativeHandle</h3>\n<p>续说上文，既然 ref 失控是因为使用了不应该使用的方法（比如 remove），那么可以限制 ref 中只存在可以使用的方法，这样就杜绝了开发者通过 ref 取到 dom 后，执行不该使用的 api，导致 ref 失控的情况。</p>\n<pre><code class=\"language-jsx\">const Input = forwardRef((props, ref) => {\n  const ref = useRef()\n  useImperativeHandle(() => {\n    return {\n      force: () => ref.current.force(),\n    }\n  })\n  return &#x3C;input {...props} ref={ref} />\n})\n</code></pre>\n<p>为了减少 ref 对 DOM 的滥用，可以使用<code>useImperativeHandle</code>限制 ref 传递的数据结构</p>","frontmatter":{"date":"2022-11-15","title":"hooks “必”坑指南","anthor":"sungy"},"excerpt":"<h1>hooks “必”坑指南</h1>\n<p>React hooks 想必已经不是什么新鲜“玩意”了，它的出现是为了开发者可以在不写<code>class</code>组件的情况使用<code>state</code>及其他 React 特性。</p>\n<h2>动机</h2>\n<p>引入 hooks 的动机，官方也是给出了答案：</p>\n<ul>\n<li>在组件之间复用状态逻辑很难</li>\n<li>复杂组件变得难以理解</li>\n<li>难以理解的 class（this 的指向问题对新手来说并不友好）</li>\n<li>由于业务变动，函数组件不得不改为类组件等等</li>…</ul>"}}]}},"pageContext":{}},"staticQueryHashes":["3649515864","63159454"],"slicesMap":{}}